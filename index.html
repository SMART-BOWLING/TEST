<!DOCTYPE html> 
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>PARTS STORE</title>
   <link rel="icon" type="image/png" href="https://i.postimg.cc/dtSpKx0W/1.png" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <!-- Google Identity Script -->
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <!-- Библиотека для генерации PDF -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js"></script>
  <style>
    /* ... (все стили остаются такими же, как в предыдущем коде) ... */
  </style>
</head>
<body>
<!-- Индикатор загрузки -->
<div class="loader-container" id="loader">
  <div class="loader"></div>
</div>

<!-- Шапка -->
<header>
  <div class="logo"><img src="https://i.postimg.cc/wjGzSY92/1.png" alt="Logo"></div>
  <div class="site-name">
    <div class="site-name-dropdown" onclick="toggleSitesDropdown(event)">
      PARTS STORE
      <div class="dropdown-sites" id="sitesDropdown">
        <a href="https://smart-bowling.github.io/PARTS-SKYMALL/">SKYMALL</a>
        <a href="https://smart-bowling.github.io/PARTS-BB/">BLOCKBUSTER</a>
        <a href="https://smart-bowling.github.io/PARTS-KH/">LUCKY STRIKE KH</a>
      </div>
    </div>
  </div>
  <div class="menu-button" onclick="toggleDropdown()">
    <div></div><div></div><div></div>
  </div>
  <div class="dropdown" id="dropdownMenu">
    <a href="https://smart-bowling.github.io/MANUALS-HTML/">
      <i class="fas fa-book"></i> МАНУАЛЫ
    </a>
  </div>
</header>

<!-- Блок авторизации -->
<div id="login">
  <h2>Вход на сайт</h2>
  <div id="g_id_onload"
       data-client_id="328749588235-bgfeukqogpoq2ha65j7j0vk840hctiaq.apps.googleusercontent.com"
       data-callback="handleCredentialResponse"
       data-auto_prompt="false">
  </div>
  <div class="g_id_signin" data-type="standard"></div>
</div>

<!-- Контент для авторизованных -->
<div id="content" style="display:none">
  <div class="top-controls" id="topControls">
    <div class="select-wrapper">
      <select id="sortSelect" title="Фильтр">
        <option value="all">Все детали</option>
        <option value="popular">Пос. взят. за 30 дней</option>
        <option value="mostPopular">Популярные</option>
        <option value="sortByQty">Остатки</option>
      </select>
    </div>
    
    <button id="btnSearch" class="btn-top">
      <i class="fas fa-search"></i> Поиск
    </button>

    <button id="btnReset" class="btn-top">
      <i class="fas fa-sync-alt"></i> Сбросить
    </button>

    <button onclick="window.open('https://smart-bowling.github.io/ADD-PARTS-STORE/', '_blank')" class="btn-top" id="btnAddPart">
      <i class="fas fa-plus-circle"></i> Добавить деталь
    </button>

    <!-- Новая кнопка для выгрузки статистики -->
    <button id="btnExportStats" class="btn-top btn-stat">
      <i class="fas fa-file-pdf"></i> Статистика
    </button>
  </div>

  <div class="cards" id="cardsContainer"></div>

  <div class="pagination" id="paginationContainer">
    <button onclick="pagination.prevPage()" id="prevBtn" disabled><i class="fas fa-arrow-left"></i> Назад</button>
    <div class="page-numbers" id="pageNumbers"></div>
    <button onclick="pagination.nextPage()" id="nextBtn">Вперёд <i class="fas fa-arrow-right"></i></button>
  </div>

  <div id="modalOverlay" class="modal-overlay">
    <div class="modal">
      <div id="modalClose" class="modal-close">×</div>
      <h3>История изменений</h3>
      <pre id="modalContent"></pre>
    </div>
  </div>

  <!-- Модальное окно для выбора диапазона дат -->
  <div id="dateRangeModal" class="modal-overlay" style="display: none;">
    <div class="modal date-range-modal">
      <div class="modal-close" onclick="closeDateRangeModal()">×</div>
      <h3>Выберите период для статистики</h3>
      <div class="date-range-controls">
        <div class="date-input-group">
          <label for="startDate">Дата начала:</label>
          <input type="date" id="startDate" value="">
        </div>
        <div class="date-input-group">
          <label for="endDate">Дата окончания:</label>
          <input type="date" id="endDate" value="">
        </div>
      </div>
      <div class="modal-buttons">
        <button onclick="generateStatisticsPDF()">Сгенерировать PDF</button>
        <button onclick="closeDateRangeModal()">Отмена</button>
      </div>
    </div>
  </div>
</div>

<script>
  // Функция для показа/скрытия индикатора загрузки
  function showLoader(show) {
    document.getElementById('loader').style.display = show ? 'flex' : 'none';
  }

  // Функция для выпадающего меню
  function toggleDropdown() {
    const menu = document.getElementById("dropdownMenu");
    menu.style.display = (menu.style.display === "flex") ? "none" : "flex";
  }

  // Функция для выпадающего списка сайтов
  function toggleSitesDropdown(event) {
    event.stopPropagation();
    const dropdown = document.getElementById("sitesDropdown");
    dropdown.style.display = (dropdown.style.display === "block") ? "none" : "block";
  }

  // Закрытие выпадающего списка при клике вне его
  document.addEventListener('click', function(e) {
    const dropdown = document.getElementById("sitesDropdown");
    const siteName = document.querySelector('.site-name-dropdown');
    
    if (dropdown.style.display === 'block' && !siteName.contains(e.target)) {
      dropdown.style.display = 'none';
    }
  });

  // Настройки авторизации
  const allowedEmails = ["vadiksss900@gmail.com", "sashavolobuev123890@gmail.com"];
  const limitedAccessEmails = ["nikoshina16@gmail.com", "bowlingblock.b@gmail.com"];

  // Обработчик ответа от Google
  function handleCredentialResponse(response) {
    showLoader(true);
    try {
      const data = parseJwt(response.credential);
      const email = data.email;

      if (allowedEmails.includes(email) || limitedAccessEmails.includes(email)) {
        localStorage.setItem("userEmail", email);
        location.reload();
      } else {
        alert("Доступ запрещён для: " + email);
      }
    } finally {
      showLoader(false);
    }
  }

  // Проверка авторизации при загрузке страницы
  window.onload = () => {
    const userEmail = localStorage.getItem("userEmail");
    if (userEmail && (allowedEmails.includes(userEmail) || limitedAccessEmails.includes(userEmail))) {
      document.getElementById("login").style.display = "none";
      document.getElementById("content").style.display = "block";
      initApp();
    }
  };

  // Функция для разбора JWT токена
  function parseJwt(token) {
    const base64Url = token.split('.')[1];
    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
    const jsonPayload = decodeURIComponent(atob(base64).split('').map(function(c) {
      return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
    }).join(''));

    return JSON.parse(jsonPayload);
  }

  // Глобальный объект для пагинации
  const pagination = {
    prevPage: function() {},
    nextPage: function() {}
  };

  // Проверка, имеет ли пользователь ограниченный доступ
  function hasLimitedAccess() {
    const userEmail = localStorage.getItem("userEmail");
    return limitedAccessEmails.includes(userEmail);
  }

  // Функции для работы с модальным окном дат
  function openDateRangeModal() {
    const today = new Date().toISOString().split('T')[0];
    const monthAgo = new Date();
    monthAgo.setDate(monthAgo.getDate() - 30);
    const monthAgoStr = monthAgo.toISOString().split('T')[0];
    
    document.getElementById('startDate').value = monthAgoStr;
    document.getElementById('endDate').value = today;
    document.getElementById('dateRangeModal').style.display = 'flex';
  }

  function closeDateRangeModal() {
    document.getElementById('dateRangeModal').style.display = 'none';
  }

  // Упрощенная функция для получения истории одной детали
  async function getPartHistory(partNumber) {
    try {
      const API_URL = "https://script.google.com/macros/s/AKfycbw-0OOaPe8sCCHW6BEhmcCJi0nRK00b3WF3dprlBcXqQIS1toSOhNhGUqFkx9AOs3pg/exec";
      const response = await fetch(`${API_URL}?action=getHistory&partNumber=${encodeURIComponent(partNumber)}`);
      return await response.text();
    } catch (error) {
      console.error(`Ошибка при получении истории для ${partNumber}:`, error);
      return '';
    }
  }

  // Функция для парсинга истории
  function parseHistory(historyText, partNumber, partName) {
    const entries = [];
    
    if (!historyText || historyText.trim() === '') {
      return entries;
    }
    
    const lines = historyText.split('\n').filter(line => line.trim() !== '');
    
    lines.forEach(line => {
      try {
        // Пытаемся разобрать строку истории
        // Ожидаемый формат: "Дата - Операция - Изменение количества - Доп.информация"
        const parts = line.split(' - ');
        
        if (parts.length >= 3) {
          const dateStr = parts[0].trim();
          const operation = parts[1].trim();
          const changeStr = parts[2].trim();
          const info = parts.slice(3).join(' - ').trim();
          
          // Извлекаем имя из информации
          let name = '';
          if (info.includes('для')) {
            const match = info.match(/для\s+(.+)/);
            if (match) name = match[1].trim();
          } else if (info) {
            name = info;
          }
          
          // Извлекаем изменение количества
          const deltaMatch = changeStr.match(/([+-]?\d+)/);
          const delta = deltaMatch ? parseInt(deltaMatch[1]) : 0;
          
          // Парсим дату
          let date;
          try {
            // Пробуем разные форматы дат
            date = parseDate(dateStr);
          } catch (e) {
            date = new Date();
          }
          
          if (name && delta !== 0) {
            entries.push({
              date: date,
              partNumber: partNumber,
              partName: partName,
              delta: delta,
              name: name,
              operation: operation,
              rawLine: line
            });
          }
        }
      } catch (e) {
        // Пропускаем строки, которые не удалось разобрать
        console.warn('Не удалось разобрать строку истории:', line);
      }
    });
    
    return entries;
  }

  // Функция для парсинга даты
  function parseDate(dateStr) {
    // Пробуем разные форматы дат
    
    // Формат: "13.01.2024 14:30:25"
    let match = dateStr.match(/(\d{1,2})\.(\d{1,2})\.(\d{4}) (\d{1,2}):(\d{2}):(\d{2})/);
    if (match) {
      const [_, day, month, year, hour, minute, second] = match;
      return new Date(year, month - 1, day, hour, minute, second);
    }
    
    // Формат: "2024-01-13 14:30:25"
    match = dateStr.match(/(\d{4})-(\d{1,2})-(\d{1,2}) (\d{1,2}):(\d{2}):(\d{2})/);
    if (match) {
      const [_, year, month, day, hour, minute, second] = match;
      return new Date(year, month - 1, day, hour, minute, second);
    }
    
    // Пробуем стандартный парсинг
    const date = new Date(dateStr);
    if (!isNaN(date.getTime())) {
      return date;
    }
    
    // Возвращаем текущую дату как fallback
    return new Date();
  }

  // Функция для генерации PDF со статистикой (упрощенная версия)
  async function generateStatisticsPDF() {
    const startDate = document.getElementById('startDate').value;
    const endDate = document.getElementById('endDate').value;
    
    if (!startDate || !endDate) {
      alert('Пожалуйста, выберите даты начала и окончания');
      return;
    }
    
    if (new Date(startDate) > new Date(endDate)) {
      alert('Дата начала не может быть позже даты окончания');
      return;
    }
    
    closeDateRangeModal();
    showLoader(true);
    
    try {
      // Получаем список всех деталей
      const allParts = window.allEntries || [];
      
      if (!allParts || allParts.length === 0) {
        alert('Нет данных о деталях');
        return;
      }
      
      // Собираем статистику только по популярным деталям (те, у которых есть история)
      let collectedData = [];
      let processedCount = 0;
      
      // Ограничим количество обрабатываемых деталей для скорости
      const maxPartsToProcess = Math.min(allParts.length, 50);
      const partsToProcess = allParts.slice(0, maxPartsToProcess);
      
      // Собираем историю только для деталей, у которых могли быть операции
      for (let i = 0; i < partsToProcess.length; i++) {
        const part = partsToProcess[i];
        
        try {
          // Показываем прогресс
          if (i % 5 === 0) {
            showLoader(true);
          }
          
          const historyText = await getPartHistory(part.partNumber);
          
          if (historyText && historyText.trim() !== '') {
            const parsedHistory = parseHistory(historyText, part.partNumber, part.partName || 'Без названия');
            collectedData = collectedData.concat(parsedHistory);
          }
          
          processedCount++;
          
          // Делаем небольшую паузу между запросами
          await new Promise(resolve => setTimeout(resolve, 200));
          
        } catch (error) {
          console.error(`Ошибка при обработке детали ${part.partNumber}:`, error);
          continue;
        }
      }
      
      // Фильтруем по дате
      const start = new Date(startDate);
      const end = new Date(endDate);
      end.setHours(23, 59, 59, 999);
      
      const filteredData = collectedData.filter(entry => {
        const entryDate = new Date(entry.date);
        return entryDate >= start && entryDate <= end && entry.delta < 0;
      });
      
      if (filteredData.length === 0) {
        alert('За выбранный период не найдено данных о взятии деталей');
        return;
      }
      
      // Группируем данные
      const stats = {};
      filteredData.forEach(entry => {
        const key = entry.partNumber;
        
        if (!stats[key]) {
          stats[key] = {
            partNumber: entry.partNumber,
            partName: entry.partName,
            totalTaken: 0,
            takers: {}
          };
        }
        
        const quantity = Math.abs(entry.delta);
        stats[key].totalTaken += quantity;
        
        if (entry.name) {
          stats[key].takers[entry.name] = (stats[key].takers[entry.name] || 0) + quantity;
        }
      });
      
      // Создаем PDF
      const { jsPDF } = window.jspdf;
      const doc = new jsPDF('p', 'mm', 'a4');
      
      // Заголовок
      doc.setFontSize(16);
      doc.setTextColor(40, 40, 40);
      doc.text('СТАТИСТИКА ВЗЯТИЯ ДЕТАЛЕЙ', 105, 20, null, null, 'center');
      
      // Информация о периоде
      doc.setFontSize(10);
      doc.setTextColor(100, 100, 100);
      doc.text(`Период: ${formatDate(startDate)} - ${formatDate(endDate)}`, 105, 30, null, null, 'center');
      doc.text(`Обработано деталей: ${processedCount} из ${allParts.length}`, 105, 35, null, null, 'center');
      
      // Подготовка данных для таблицы
      const tableData = [];
      const statsArray = Object.values(stats);
      
      // Сортируем по количеству взятых
      statsArray.sort((a, b) => b.totalTaken - a.totalTaken);
      
      // Ограничим количество строк в таблице
      const maxRows = Math.min(statsArray.length, 100);
      const displayStats = statsArray.slice(0, maxRows);
      
      displayStats.forEach(stat => {
        const takersList = Object.entries(stat.takers)
          .map(([name, qty]) => `${name}: ${qty}`)
          .join('; ');
        
        tableData.push([
          stat.partNumber,
          stat.partName.substring(0, 30) + (stat.partName.length > 30 ? '...' : ''),
          stat.totalTaken.toString(),
          takersList.substring(0, 50) + (takersList.length > 50 ? '...' : '') || 'Нет данных'
        ]);
      });
      
      // Добавляем таблицу
      doc.autoTable({
        startY: 45,
        head: [['Номер детали', 'Название', 'Взято всего', 'Кто взял']],
        body: tableData,
        theme: 'grid',
        headStyles: {
          fillColor: [220, 20, 60],
          textColor: 255,
          fontStyle: 'bold'
        },
        styles: {
          fontSize: 8,
          cellPadding: 2,
          overflow: 'linebreak',
          cellWidth: 'wrap'
        },
        columnStyles: {
          0: { cellWidth: 30 },
          1: { cellWidth: 45 },
          2: { cellWidth: 20 },
          3: { cellWidth: 95 }
        },
        margin: { left: 10, right: 10 },
        pageBreak: 'auto'
      });
      
      // Итоговая статистика
      const finalY = doc.lastAutoTable.finalY + 10;
      
      if (finalY < 280) {
        doc.setFontSize(10);
        doc.setTextColor(40, 40, 40);
        
        const totalTaken = displayStats.reduce((sum, stat) => sum + stat.totalTaken, 0);
        const totalOperations = filteredData.length;
        const uniqueParts = displayStats.length;
        const uniqueTakers = new Set();
        displayStats.forEach(stat => {
          Object.keys(stat.takers).forEach(taker => uniqueTakers.add(taker));
        });
        
        doc.text(`Общая статистика:`, 10, finalY);
        doc.text(`• Всего операций взятия: ${totalOperations}`, 10, finalY + 7);
        doc.text(`• Уникальных деталей: ${uniqueParts}`, 10, finalY + 14);
        doc.text(`• Всего взято деталей: ${totalTaken}`, 10, finalY + 21);
        doc.text(`• Уникальных сотрудников: ${uniqueTakers.size}`, 10, finalY + 28);
        
        if (statsArray.length > maxRows) {
          doc.text(`* Показано ${maxRows} из ${statsArray.length} деталей`, 10, finalY + 35);
        }
      }
      
      // Сохраняем PDF
      const fileName = `Статистика_${startDate}_${endDate}.pdf`;
      doc.save(fileName);
      
      alert(`Статистика успешно сгенерирована!\nОбработано деталей: ${processedCount}\nНайдено операций: ${filteredData.length}`);
      
    } catch (error) {
      console.error('Ошибка при генерации PDF:', error);
      alert('Произошла ошибка при генерации отчета: ' + error.message);
    } finally {
      showLoader(false);
    }
  }

  // Функция для форматирования даты
  function formatDate(dateStr) {
    const date = new Date(dateStr);
    return date.toLocaleDateString('ru-RU');
  }

  // Инициализация приложения
  function initApp() {
    const API_URL = "https://script.google.com/macros/s/AKfycbw-0OOaPe8sCCHW6BEhmcCJi0nRK00b3WF3dprlBcXqQIS1toSOhNhGUqFkx9AOs3pg/exec";

    let allEntries = [];
    let currentEntries = [];
    let currentPage = 1;
    let totalPages = 1;
    const cardsPerPage = 5;

    // Основные функции приложения
    async function getEntries() {
      showLoader(true);
      try {
        const res = await fetch(`${API_URL}?action=getEntries`);
        return await res.json();
      } finally {
        showLoader(false);
      }
    }

    async function updateQuantity(partNumber, delta) {
      showLoader(true);
      try {
        const res = await fetch(`${API_URL}?action=updateQuantity&partNumber=${encodeURIComponent(partNumber)}&delta=${delta}`);
        return await res.json();
      } finally {
        showLoader(false);
      }
    }

    async function updateQuantityWithName(partNumber, delta, name) {
      showLoader(true);
      try {
        const res = await fetch(`${API_URL}?action=updateQuantityWithName&partNumber=${encodeURIComponent(partNumber)}&delta=${delta}&name=${encodeURIComponent(name)}`);
        return await res.json();
      } finally {
        showLoader(false);
      }
    }

    async function deleteEntry(rowIndex) {
      showLoader(true);
      try {
        const res = await fetch(`${API_URL}?action=deleteEntry&rowIndex=${rowIndex}`);
        return await res.json();
      } finally {
        showLoader(false);
      }
    }

    async function getHistory(partNumber) {
      showLoader(true);
      try {
        const res = await fetch(`${API_URL}?action=getHistory&partNumber=${encodeURIComponent(partNumber)}`);
        return await res.text();
      } finally {
        showLoader(false);
      }
    }

    async function getPopularEntries() {
      showLoader(true);
      try {
        const res = await fetch(`${API_URL}?action=getPopularEntries`);
        return await res.json();
      } finally {
        showLoader(false);
      }
    }

    async function getMostPopularEntries() {
      showLoader(true);
      try {
        const res = await fetch(`${API_URL}?action=getMostPopularEntries`);
        return await res.json();
      } finally {
        showLoader(false);
      }
    }

    async function updatePartName(partNumber, newName) {
      showLoader(true);
      try {
        const res = await fetch(`${API_URL}?action=updatePartName&partNumber=${encodeURIComponent(partNumber)}&newName=${encodeURIComponent(newName)}`);
        return await res.json();
      } finally {
        showLoader(false);
      }
    }

    function createCard(entry) {
      const div = document.createElement('div');
      div.className = 'card';
      div.dataset.row = entry.rowIndex;
      div.dataset.partNumber = entry.partNumber.toLowerCase();

      // Добавляем класс для ограниченного доступа, если нужно
      if (hasLimitedAccess()) {
        div.classList.add('limited-access');
      }

      const media = document.createElement('div');
      media.className = 'media-block';

      if (entry.fileUrl && entry.fileUrl.includes('/preview')) {
        const iframe = document.createElement('iframe');
        iframe.src = entry.fileUrl;
        media.appendChild(iframe);
      } else if (entry.fileUrl) {
        const img = document.createElement('img');
        img.src = entry.fileUrl;
        media.appendChild(img);
      }

      const overlay = document.createElement('div');
      overlay.className = 'img-overlay';
      media.appendChild(overlay);

      // Для пользователей с ограниченным доступом скрываем кнопку удаления
      if (!hasLimitedAccess()) {
        const rem = document.createElement('div');
        rem.className = 'icon remove';
        rem.textContent = 'Х';
        media.append(rem);

        rem.onclick = async () => {
          if (confirm('Удалить эту запись?')) {
            await deleteEntry(entry.rowIndex);
            allEntries = allEntries.filter(e => e.rowIndex !== entry.rowIndex);
            currentEntries = currentEntries.filter(e => e.rowIndex !== entry.rowIndex);
            updateTotalPages();
            if (currentPage > totalPages) currentPage = totalPages;
            renderPage(currentPage);
          }
        };
      }

      div.append(media);

      // Для пользователей с ограниченным доступом создаем красивую строку с информацией
      if (hasLimitedAccess()) {
        const partInfoContainer = document.createElement('div');
        partInfoContainer.className = 'part-info-container';
        
        const partNumberItem = document.createElement('div');
        partNumberItem.className = 'part-info-item part-number';
        partNumberItem.textContent = entry.partNumber;
        
        const partNameItem = document.createElement('div');
        partNameItem.className = 'part-info-item part-name';
        partNameItem.textContent = entry.partName || 'Название детали';
        
        const partQuantityItem = document.createElement('div');
        partQuantityItem.className = 'part-info-item part-quantity';
        partQuantityItem.textContent = entry.quantity;
        
        partInfoContainer.appendChild(partNumberItem);
        partInfoContainer.appendChild(partNameItem);
        partInfoContainer.appendChild(partQuantityItem);
        
        div.appendChild(partInfoContainer);
      } else {
        // Для обычных пользователей оставляем стандартный вид
        const partNameContainer = document.createElement('div');
        partNameContainer.className = 'part-name-container';
        partNameContainer.dataset.partNumber = entry.partNumber;
        
        const partNameText = document.createElement('div');
        partNameText.className = 'part-name-text';
        partNameText.textContent = entry.partName || 'Название детали';
        
        const editButton = document.createElement('button');
        editButton.className = 'part-name-edit-btn';
        editButton.innerHTML = '<i class="fas fa-edit"></i>';
        editButton.title = 'Редактировать название';
        
        partNameContainer.appendChild(partNameText);
        partNameContainer.appendChild(editButton);

        // Обработчик клика для кнопки редактирования
        editButton.addEventListener('click', function() {
          const partNumber = partNameContainer.dataset.partNumber;
          const currentName = partNameText.textContent;
          
          // Переходим в режим редактирования
          partNameContainer.classList.add('editing');
          
          const input = document.createElement('input');
          input.type = 'text';
          input.className = 'part-name-input';
          input.value = currentName;
          
          const saveButton = document.createElement('button');
          saveButton.className = 'part-name-save-btn';
          saveButton.innerHTML = '<i class="fas fa-check"></i>';
          saveButton.title = 'Сохранить';
          
          const cancelButton = document.createElement('button');
          cancelButton.className = 'part-name-cancel-btn';
          cancelButton.innerHTML = '<i class="fas fa-times"></i>';
          cancelButton.title = 'Отменить';
          
          // Заменяем содержимое контейнера
          partNameText.style.display = 'none';
          editButton.style.display = 'none';
          
          partNameContainer.appendChild(input);
          partNameContainer.appendChild(saveButton);
          partNameContainer.appendChild(cancelButton);
          
          input.focus();
          input.select();
          
          // Функция завершения редактирования
          const finishEdit = async (save = false) => {
            const newName = save ? input.value.trim() : currentName;
            
            partNameContainer.classList.remove('editing');
            input.remove();
            saveButton.remove();
            cancelButton.remove();
            
            partNameText.style.display = '';
            editButton.style.display = '';
            
            if (save && newName && newName !== currentName) {
              const res = await updatePartName(partNumber, newName);
              if (res.status === 'success') {
                partNameText.textContent = newName;
                // Обновляем название в массиве записей
                const updatedEntry = allEntries.find(e => e.partNumber === partNumber);
                if (updatedEntry) updatedEntry.partName = newName;
              } else {
                alert(res.message || 'Ошибка при обновлении названия');
              }
            }
          };
          
          // Обработчики для кнопок
          saveButton.addEventListener('click', () => finishEdit(true));
          cancelButton.addEventListener('click', () => finishEdit(false));
          
          input.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
              finishEdit(true);
            }
          });
          
          input.addEventListener('blur', () => {
            // Не завершаем редактирование при потере фокуса
          });
        });

        div.append(partNameContainer);

        const controls = document.createElement('div');
        controls.className = 'controls';

        const pill = document.createElement('div');
        pill.className = 'pill';
        pill.textContent = entry.partNumber;

        const qtyInput = document.createElement('input');
        qtyInput.type = 'text';
        qtyInput.value = entry.quantity;
        qtyInput.readOnly = true;

        const btnAdd = document.createElement('button');
        btnAdd.className = 'btn btn-add';
        btnAdd.innerHTML = '<i class="fas fa-plus-circle"></i> ДОБАВИТЬ';

        const btnInfo = document.createElement('button');
        btnInfo.className = 'btn btn-info';
        btnInfo.innerHTML = '<i class="fas fa-history"></i> ИСТОРИЯ';

        const btnTake = document.createElement('button');
        btnTake.className = 'btn btn-take';
        btnTake.innerHTML = '<i class="fas fa-shopping-cart"></i> ВЗЯТЬ';

        controls.append(pill, qtyInput, btnAdd, btnInfo, btnTake);
        div.append(controls);

        btnAdd.onclick = async () => {
          const deltaStr = prompt('Введите число для добавления:');
          const delta = Number(deltaStr);
          if (deltaStr !== null && !isNaN(delta)) {
            const res = await updateQuantity(entry.partNumber, delta);
            if (res.status === 'success') {
              qtyInput.value = res.quantity;
              entry.quantity = res.quantity;
            } else {
              alert(res.message);
            }
          }
        };

        btnTake.onclick = async () => {
          const quantity = prompt('Введите количество для вычитания:');
          if (quantity === null) return;
          
          const qtyNum = parseInt(quantity);
          if (isNaN(qtyNum) || qtyNum <= 0) {
            alert('Пожалуйста, введите корректное число');
            return;
          }
          
          const name = prompt('Введите имя или номер телефона:');
          if (name === null) return;
          
          if (!name.trim()) {
            alert('Пожалуйста, введите имя или номер телефона');
            return;
          }
          
          const res = await updateQuantityWithName(entry.partNumber, -qtyNum, name.trim());
          if (res.status === 'success') {
            qtyInput.value = res.quantity;
            entry.quantity = res.quantity;
          } else {
            alert(res.message);
          }
        };

        btnInfo.onclick = async () => {
          const hist = await getHistory(entry.partNumber);
          document.getElementById('modalContent').textContent = hist;
          document.getElementById('modalOverlay').style.display = 'flex';
        };
      }

      return div;
    }

    function updateTotalPages() {
      totalPages = Math.ceil(currentEntries.length / cardsPerPage) || 1;
    }

    function renderPage(page) {
      const container = document.getElementById('cardsContainer');
      if (!container) return;
      
      container.innerHTML = '';

      const start = (page - 1) * cardsPerPage;
      const end = start + cardsPerPage;
      const pageData = currentEntries.slice(start, end);

      if (pageData.length === 0) {
        container.innerHTML = '<div class="no-data">Нет данных для отображения</div>';
        return;
      }

      pageData.forEach(entry => {
        const card = createCard(entry);
        container.appendChild(card);
      });

      if (!hasLimitedAccess()) {
        renderPageNumbers();
        updatePaginationControls();
      }
      window.scrollTo(0, 0);
    }

    function renderPageNumbers() {
      const pageContainer = document.getElementById('pageNumbers');
      if (!pageContainer) return;
      
      pageContainer.innerHTML = '';
      
      const maxVisiblePages = 5;
      let startPage = Math.max(currentPage - 2, 1);
      let endPage = Math.min(startPage + maxVisiblePages - 1, totalPages);
      
      if (startPage > 1) {
        addPageButton(1);
        if (startPage > 2) {
          addDots();
        }
      }
      
      for (let i = startPage; i <= endPage; i++) {
        addPageButton(i);
      }
      
      if (endPage < totalPages) {
        if (endPage < totalPages - 1) {
          addDots();
        }
        addPageButton(totalPages);
      }
      
      function addPageButton(page) {
        const btn = document.createElement('button');
        btn.textContent = page;
        if (page === currentPage) {
          btn.classList.add('active');
        }
        btn.onclick = () => goToPage(page);
        pageContainer.appendChild(btn);
      }
      
      function addDots() {
        const dots = document.createElement('span');
        dots.textContent = '...';
        dots.style.padding = '0 10px';
        pageContainer.appendChild(dots);
      }
    }

    function goToPage(page) {
      if (page < 1 || page > totalPages) return;
      
      currentPage = page;
      renderPage(currentPage);
      updatePaginationControls();
    }

    // Обновляем глобальные функции пагинации
    pagination.nextPage = function() {
      if (currentPage < totalPages) {
        goToPage(currentPage + 1);
      }
    };

    pagination.prevPage = function() {
      if (currentPage > 1) {
        goToPage(currentPage - 1);
      }
    };

    function updatePaginationControls() {
      const prevBtn = document.getElementById('prevBtn');
      const nextBtn = document.getElementById('nextBtn');
      
      if (prevBtn) prevBtn.disabled = currentPage <= 1;
      if (nextBtn) nextBtn.disabled = currentPage >= totalPages;
    }

    function resetSearch() {
      currentEntries = [...allEntries];
      updateTotalPages();
      currentPage = 1;
      renderPage(currentPage);
      document.getElementById('sortSelect').value = 'all';
    }

    // Инициализация событий
    document.getElementById('btnSearch')?.addEventListener('click', () => {
      const term = prompt('Введите номер детали для поиска:');
      if (term !== null) {
        const searchTerm = term.toLowerCase().trim();
        currentEntries = searchTerm.length === 0 
          ? [...allEntries] 
          : allEntries.filter(e => e.partNumber.toLowerCase().includes(searchTerm));
        updateTotalPages();
        currentPage = 1;
        renderPage(currentPage);
        document.getElementById('sortSelect').value = 'all';
      }
    });

    document.getElementById('btnReset')?.addEventListener('click', () => {
      currentEntries = [...allEntries];
      updateTotalPages();
      currentPage = 1;
      renderPage(currentPage);
      document.getElementById('sortSelect').value = 'all';
    });

    // Добавляем обработчик для кнопки статистики
    document.getElementById('btnExportStats')?.addEventListener('click', () => {
      openDateRangeModal();
    });

    document.getElementById('sortSelect')?.addEventListener('change', async function() {
      showLoader(true);
      try {
        if (this.value === 'all') {
          currentEntries = [...allEntries];
        } else if (this.value === 'popular') {
          currentEntries = await getPopularEntries();
          if (currentEntries && currentEntries[0]?.lastChangeDate) {
            currentEntries.sort((a, b) => new Date(b.lastChangeDate) - new Date(a.lastChangeDate));
          }
        } else if (this.value === 'mostPopular') {
          currentEntries = await getMostPopularEntries();
          if (!currentEntries?.length) {
            alert('Нет данных для сортировки "всё время"');
            return;
          }
        } else if (this.value === 'sortByQty') {
          currentEntries = [...allEntries].sort((a, b) => a.quantity - b.quantity);
        }
        
        updateTotalPages();
        currentPage = 1;
        renderPage(currentPage);
      } finally {
        showLoader(false);
      }
    });

    document.getElementById('modalClose')?.addEventListener('click', () => {
      document.getElementById('modalOverlay').style.display = 'none';
    });

    document.getElementById('modalOverlay')?.addEventListener('click', (e) => {
      if (e.target === document.getElementById('modalOverlay')) {
        document.getElementById('modalOverlay').style.display = 'none';
      }
    });

    // Загрузка данных
    async function loadData() {
      showLoader(true);
      try {
        allEntries = await getEntries();
        // Сохраняем в глобальную переменную для доступа из других функций
        window.allEntries = allEntries;
        
        currentEntries = [...allEntries];
        
        // Для пользователей с ограниченным доступом показываем все записи сразу
        if (hasLimitedAccess()) {
          const container = document.getElementById('cardsContainer');
          container.innerHTML = '';
          
          allEntries.forEach(entry => {
            const card = createCard(entry);
            container.appendChild(card);
          });
        } else {
          updateTotalPages();
          renderPage(currentPage);
        }
      } finally {
        showLoader(false);
      }
    }

    loadData();
  }
</script>
</body>
</html>